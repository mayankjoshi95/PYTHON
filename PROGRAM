#RAISE AN ERROR EXCEPTION



def banner_text(text):
    screen_width = 50
    if len(text) > screen_width - 4:
        raise ValueError("String{0}is larger then specified width{1}".format(text,screen_width))

    if text == "*":
        print("*" * screen_width)
    else:
        centred_text = text.center(screen_width - 4)
        output_string = "**{0}**".format(centred_text)
        print(output_string)


banner_text("*")
banner_text("Always look on the bright side of life...")
banner_text("If life seems jolly rotten,")
banner_text("There's something you've forgotten!")
banner_text("And that's to laugh and smile and dance and sing,")
banner_text(" ")
banner_text("When you're feeling in the dumps,")
banner_text("Don't be silly chumps,")
banner_text("Just purse your lips and whistle - that's the thing!")
banner_text("And... always look on the bright side of life...")
banner_text("*")





#palindrome




def palindrome(string:str)->bool:
    return string[::-1].casefold()==string.casefold()
word= input()
stri=palindrome(word)
print(stri)




#fibonacci Numbers



def  fibonacci(n):
    if 0<=n<=1:
        return n
    fe= 1
    
    fw= 0
    for f in range(n-1):
        result=int(fe)+int(fw)
        fw=fe
        fe=result
    return result

for i in range(32):
    print(i,fibonacci(i))





#args
def test_start(*args):
    print(args)
    for x in args:
        print(x)
test_start(0,1,2,3,4,5) 
 
 
 
 
 
 
 #DICTIONARY
 
 
 fruit={"orange":"sweet orange citrus fruit",
        "apple":"good for making cider",
         "lemon":"sour yellow citrus fruti",
      "grape":"samll fruit",
      "lime":"small citurs sour "}
print(fruit)
print(fruit['lemon'])
#assign new values to dictionary
fruit["banana"]="healthy"
print(fruit)
#overwriting
fruit["apple"]="verygood "
#delete 
del fruit["banana"]
#clear
fruit.clear()



#get method
while True:
    dict_key=input("Please enter a fruit")
    if dict_key=="quit":
        break
    description=fruit.get(dict_key)
    print(description)
    
    
    
    
    #sorting using keys and values
    #insted of keys place values()
   
  ordered_keys=fruits.keys()
ordered_keys=sorted(list(fruits.keys()))
print(ordered_keys)
for f in ordered_keys:
    print(f+"="+fruits[f])
    
    
    
    
    #tuple and dictionary
    
    f_tuple=tuple(fruits.items())
    for i in f_tuple:
    item,description=i
    print(item+"is"+description)

    
#join


mylist=["a","b","c","d"]
print(mylist)
newString=""

newString+=",".join(mylist)
print(newString)  







#update copy DICTIONARY


fruits={"orange":"sweet orange citrus fruit",
        "apple":"good for making cider",
         "lemon":"sour yellow citrus fruti",
         "grape":"samll fruit",
         "lime":"small citurs sour ",
         "apple":"healthy"}
veg={"cabage":"every childs favorite",
    "sprouts":"mm lovely",
    "spinach":"can i have some more fruits"}

nicenasty=fruits.copy()
nicenasty.update(veg)
print(nicenasty)




#sets,union,intersection






farmanimal={"sheep","cow","deer"}
print(farmanimal)
for animal in farmanimal:
    print(animal)
wild=set(["lion","tiger","panther"])
print(wild)
for animal in wild:
    print(animal)
empty_set=set()
empty_set.add("Sdds")
print(empty_set)

even=set(range(0,40,2))
print(even)
print(len(even))
square_tuple=(4,16,3,2,4)
squares=set(square_tuple)
print(squares)
print(len(squares))
print(even.union(squares))
print(len(even.union(squares)))
print(even.intersection(squares))
print(even-squares)
print(even.difference(squares))




#file 


jabber=open("/Users/home/.jupyter/sample.txt",'r')
for line in jabber:
     print(line,end='')
jabber.close()    




#using pickle





inelda="more mayhem","ineehlda may","2011",((1,"puling the rug"),(2,"psycho"),(3,"mayhem"),(4,"kentish town waltz"))
even=list(range(0,10,2))
odd=list(range(1,10,2))
with open("inelda.pickle","wb") as pickle_file:
    pickle.dump(inelda,pickle_file)
    pickle.dump(even,pickle_file)
    pickle.dump(odd,pickle_file)
    pickle.dump(29998302,pickle_file)
with open("inelda.pickle","rb")as inelda_pickled:
    inelda2=pickle.load(inelda_pickled)
    even_list=pickle.load(inelda_pickled)
    odd_list=pickle.load(inelda_pickled)
    x=pickle.load(inelda_pickled)
    
print(inelda2)
album,artist,year,track_list=inelda2
print(album)
print(artist)
print(year)
print(track_list)
for track in track_list:
    track_number,track_title=track
    print(track_number,track_title)
for i in even_list:
    print(i)
for i in odd_list:
    print(i)
print(x)    




#using shelves



import shelve
blt=["bacon","tomatoes","lettuce","bread"]
beans_on_toast=["beans","bread"]
scrambled_eggs=["eggs","butter","milk"]
soup=["tin of soup"]
pasta=["pasta","cheeze"]
with shelve.open("recipes",writeback=True) as recipes:
   # recipes["blt"]=blt
    #recipes["beans_on_toast"]=beans_on_toast
    #recipes["scrambled_eggs"]=scrambled_eggs
    #recipes["soup"]=soup
    #recipes["pasta"]=pasta
    recipes["soup"]=soup
    temp_list=recipes["blt"]
    temp_list.append("butter")
    recipes["blt"]=temp_list
    temp_list=recipes["pasta"]
    temp_list.append("tomato")
    recipes["pasta"]=temp_list
    recipes["soup"].append("cruotons")        
    
    for snack in recipes:
        print(snack,recipes[snack])
    
    
    
    
    
    
    #program using turtle
    
    
    
import turtle
turtle.forward(150)
turtle.right(250)
turtle.forward(150)





#why import * is a problem



done="well done you have finished the drawing"
from turtle import *
forward(150)
right(250)
forward(150)
done()
print(done)

<function mainloop at 0x000001F851FC4160>#output



#directory


print(dir())

#for example

for n in dir(__builtin__):
    print(n)
    
    
    import shelve
for obj in dir(shelve.Shelf):
    if obj[0]!="_":
        print(obj)

#open web browser in python
import webbrowser
webbrowser.open("https://www.unicef.org/")




#time

import time
print(time.gmtime(0))
print(time.localtime())
print(time.time())


time_here=time.localtime()
print(time_here)
print("year:",time_here[0],time_here.tm_year)
print("month",time_here[1],time_here.tm_mon)
print("day",time_here[2],time_here.tm_mday)


#program for storing my reaction time

import time
from time import perf_counter as my_timer #instead of perf_counter ;time can be used ,or process time can be used 
import random
input("please enter to start")
wait_time=random.randint(1,6)
time.sleep(wait_time)
start_time=my_timer()
input("press enter to stop")
end_time=my_timer()
print("started at"+time.strftime("%X",time.localtime(start_time)))
print("ended at"+time.strftime("%X",time.localtime(end_time)))
print("your reaction time was{}".format(end_time-start_time))



#date time  pytz



import pytz
import datetime
country="Europe/Moscow"
tz_to_display=pytz.timezone(country)
local_time=datetime.datetime.now(tz=tz_to_display)
print("the time in{}is {}\n\t".format(country,local_time))
print("UTCis {}\n\t".format(datetime.datetime.utcnow()))



for x in sorted(pytz.country_names):
    print("{}:{}:{}".format(x,pytz.country_names[x],pytz.country_timezones.get(x)))

#country with their time and how much ahead of utc

for x in sorted(pytz.country_names):
    print("{}:{}".format(x,pytz.country_names[x],end=':'))
    if x in pytz.country_timezones:
        for zone in sorted(pytz.country_timezones[x]):
            tz_to_display=pytz.timezone(zone)
            local_time=datetime.datetime.now(tz=tz_to_display)
            print(zone,local_time)
    else:
          print("no time zones")
          
          
         
#FUNCTION IN PYTHON
def text(*args):
    text=""
    for arg in args:
        text+=str(arg)
    left_margin=(80-len(text))//2
    print(" "*left_margin,text)
text("my name is mayank")   
text("my name is mfgdggsgseayank")
text(12)
text("my name is mayanksgdsgsfawfeagesgsgs")
text("sds",2,322,33,"sds")






#use of file in print function

def text(*args, sep='',end='\n', file=None, flush=False):
    text=""
    for arg in args:
        text+=str(arg)+sep
    left_margin=(80-len(text))//2
    print(" "*left_margin,text,end=end,file=file,flush=flush)
with open("centered",mode='w') as centered_file:
    
 text("my name is mayank",file=centered_file)   
 text("my name is mfgdggsgseayank",file=centered_file)
 text(12,file=centered_file)
 text("my name is mayanksgdsgsfawfeagesgsgs",file=centered_file)
 text("sds",2,322,33,"sds",sep="",file=centered_file)



#CLASS 
object oriented programming aims to combine data and the processes that act on that data into object called encapsulation

##encapsulation of data is the self lightng cigerrate 
withut object oriented programming steps for smoking the sigarrete is 
1.place cigarette in mouth 
2.lisght the match 
3.hold the match to cigrete
4. inhale 

encapsulation 
1.place cigarrete in mouth 
2. inhale 

but there is no magic involved here steps still has to be programmed so they are built into the object so anything using the object doesn't have to be concerned about them .
a=12
b=4
print(a+b)
print(a.__add__(b))
##here even if we send any thing it calls the same fucntion in .py file 
##in python everything is an object even types are implemeted as classes .
#when a function is  apart of class in pyhton it is called the method 


class Kettle(object):
power_source="electricity"
    def __init__(self , make,price):
        self.make=make
        self.price=price
        self.on=False##thus class can be thought of as a template from which object is created
    def switch_on(self):
      self.on=True
        #object created have the same name and the price 
        ##object created from the same class will share the same characteristics .
        ##so if i now create a kettle called kenwood then kettle will be an instance of the kettle class or kenwood is an obbject of type kettle a
kenwood=Kettle("kenwood",8.99)
print(kenwood.make)
print(kenwood.price)
kenwood.price=12.75
print(kenwood.price)
hamilton=Kettle("hamilton",14.55)
print("models:{0.make}={0.price},{1.make}={1.price}".format(kenwood,hamilton))
##each instance i.e the hamilton or the kenwood has its value for name and price  
##once the calss is defined then ewe can create as many instance of the class as we want .
#once the instance is created we can then call the method and access their variable 
#so kenwood.price retrieves the price from the instance called the kenwood .
##when a variable is bund to an instance of a class it is called data attribute
print(Kettle.power_source)
print(kenwood.power_source)
print(hamilton.power_source)
electricity
electricity
electricity
kenwood.power_source="atomic"
electricity
atomic
electricity


###Class:-template for creating the objects .all objects are created using the same classs will have the same chracteristics
###object :-an instance of the class
###instantiate :-create an instance of the class 
###method: a function defined in a class
###attribute :-a variable bound to an instance of the class
##difference between this method and the function is the self parameter 
##self :- it is the reference to the instance of the class and it is used to refer to instance variable 



##instances ,constructors ,self and more 
#CLASS bank balance
##print(hamilton.on)
##print(hamilton.switch_on())
##print(hamilton.on)
##Kettle.switch_on(kenwood)##calling the switch method in an alternative way so instead of using the instance of the kettle to call we used class itsel f
##print(kenwood.on)
##constructor :-special method executed when the instance of the class is created or constructed ##in python it is the init method on the line 3

###along with thhe instance variable there can also be the class attribute 

class Account:
    """simple account class with balance"""
    def __init__(self,name,balance):
        self.name=name
        self.balance=balance
        print("account created for"+name)
    def deposit(self,amount):    
        if amount>0:
            self.balance+=amount
            self.show_balance()
    def withdraw(self,amount):
        if 0<amount<=self.balance:
            self.balance-=amount
        else:
            print("greater than alowed")
            self.show_balance()
    def show_balance(self):
        print("balance is {}".format(self.balance))
if __name__=="__main__":
    tim=Account("tim",0)
  #  tim.show_balance()
    tim.deposit(1000)
    tim.withdraw(50000)
   # tim.show_balance()
    
##if name=='__main__'##name value is equal to the main if your are running int he same program the fucntion you are calling 
def printhar(string):
    return f"ye string de de {string}"
def add(num1,num2):
    return num1 +num2+5
if __name__=='__main__':##if we import tut1 then only the function performed in the second is executed unless not 
#here it says that if name === main then only execute so when name ==main only when it is its function
    print(printhar("harry 1"))
    o=add(4,5)
    print(o)
ye string de de harry 1
14

import tut1
print(tut1.add(4,3))
12








#sepositing and withdrawing amount and showing their utc time

import datetime
import pytz
class Account:
    """simple account class with balance"""
    @staticmethod
    def _current_time():
        utc_time=datetime.datetime.utcnow()
        return pytz.utc.localize(utc_time)
    def __init__(self,name,balance):
        self.name=name
        self.balance=balance
        self.transaction_list=[]
        print("account created for"+name)
    def deposit(self,amount):    
        if amount>0:
            self.balance+=amount
            self.show_balance()
            self.transaction_list.append((Account._current_time(),amount))
    def withdraw(self,amount):
        if 0<amount<=self.balance:
            self.balance-=amount
            self.transaction_list.append((Account._current_time(),-amount))
        else:
            print("greater than alowed")
            self.show_balance()
    def show_balance(self):
        print("balance is {}".format(self.balance))
    def show_transations(self):
        for date,amount in self.transaction_list:
            if amount>0:
                tran_type="deposited"
            else:
                tran_type="withdraw"
                amount*=-1
            print("local time was",amount,tran_type,date,date.astimezone())    
if __name__=="__main__":
    tim=Account("tim",0)
  #  tim.show_balance()
    tim.deposit(1000)
    tim.withdraw(7)
    tim.show_balance()
    tim.show_transations()
    steph=Account("steph",800)
    steph.deposit(100)
    steph.withdraw(200)
    steph.show_transations()
    steph=Account("steph",800)
    steph.deposit(800)
    steph.withdraw(400)
    steph.show_transations()
###raw string  :help to not use \\ it help in case where we have to put \ at the end of the line .
##DOCSTRINGS 
class Song :
    """Class to represent a song 
    Attributes :
    title(str):title of the song 
    artist(artist) :an artist object represneting the song creater
    duration (int):duration of the song in second 
    """
    def __init__(self,title,artist,duration=0):
     """Song init method 
     Args:
     title(str):initialises the 'title 'attribute 
     artist(Artist):an artist object representig the song creator 
     duration(optional (int)):;initial value for the duration of the attributes 
     will default value to the zero if not specified """
     self.title =title 
     self.artist=artist
     self.duration=duration     
help(Song.__init__.__doc__)    
Song.__init__.__doc__= """Song init method 
     Args:
     title(str):initialises the 'title 'attribute 
     artist(Artist):an artist object representig the song creator 
     duration(optional (int)):;initial value for the duration of the attributes 
     will default value to the zero if not specified """
help(Song)


class Album :
    """class to represent an album using a track list
    attributes:
    album _name(str):the name of the album
    year(int): the year the album wa sreleased 
    artist :(Artist responsible for the album )
    if not specified the artist will default to an artist
    tracks (list):a list of song of the album 
    methods :
    add song:add a new  song to the album track list 
    """
    def __init__(self,name,year,artist=None ):
        self.name=name
        self.year=year
        if artist  is None :
             self.artist=Artist("Various artist ")
        else:
            self.artist=artist 
        self.tracks=[]    
    def add_song(self,song,postion=None):
        """Adds a song to the track list 
        args:
        song[song]:song to add
        position (int):if specified song will be added to that postion in the track list 
        -inserting it between other songs if necessary """
        if position is None :
           self.tracks.append(song)
        else:
           self.tracks.insert(position,song)
        
class Artist :
    """basic class to store artist details 
    attributes :
    name(str): the name of the artist 
    album/List(album):a list of the album by the artist 
    the list includes only those album in the colletionit is not 
    an exhaust list of artist published albums 
    methods :add_albums :use to add a new album to the artist album list """
    def __init__(self,name ):
        self.name=name
        self.albums=[]
        
    def add_album(self,album):
        """add new album to the list..
        args: 
        album(Album ):album object to add to the list 
        if the album is already present .it will not added again(althpugh it is yet implemented"""
        self.albums.append(album)
def load_data():
    new_artist=None
    new_album=None
    artist_list=[]
    with open("C:\\Users\\home\\Downloads\\albums.txt","r") as albums:
       for line in albums:
            #data row shouldconsist of (artist,album,year,song)
         artist_field,album_field,year_field,song_field=tuple(line.strip('\n').split('\t'))
         year_field=int(year_field)
         print( artist_field,album_field,year_field,song_field) 
         if new_artist is None :
                new_artist=Artist(artist_field)
         elif new_artist.name!=artist_field:
            #we've just read the details for the new artist 
            #store the current album in the current artist collection then create a new artist object 
            new_artist.add_album(new_album)
            artist_list.append(new_artist)
            new_artist=Artist(artist_field)
            new_album=None 
         if new_album is None :
                new_album=Album(album_field,year_field,new_artist)
         elif new_album.name!=album_field:
            #we've just read the details for the new album
            #store the current album in the current artist collection then create a new artist object 
            new_artist.add_album(new_album)
            new_album=Album(album_field,year_field,new_artist)
         #create a new song object anndadd it to the current album's collection   
         new_song=Song(song_field,new_artist)
         new_album.add_song(new_song)
         if new_artist is not None :
                 if new_album is not None :
                        new_artist.add_album(new_album)
                 artist_list.append(new_artist)
    return artist_list             
if __name__=='__main__':
    
    load_data()


num1=(input())
num2=(input())
try:
 print(" the number is ",int(num1)+int(num2))
except Exception as e:
    print(e)
print("this is something")
wee
6
invalid literal for int() with base 10: 'wee'
this is something


##check file 
def create_checkfile(artist_list):
    """create a check file from the object data for the coparision with the original file"""
    with open("checkfile.txt","w") as checkfile:
        for new_artist in artist_list:
            for new_album in new_artist.albums:
                for new_song in new_album.tracks:
                    print("{0.name}\t{1.name}\t{1.year}\t{2.title}".format(new_artist,new_album,new_song),file=checkfile)
    

##encasulting involvess encapsulating data and methods
###it deals with question such as which object is best suited to deal with this task or where does responsibility to perform this function belong 
##here load data does all the work of passing the data and working out when it finds the new album and a new song  .here the one who know most about the album is the artist and 
albums knows all about songs 
##so we really should encapsulte the method for dealing wth albums in the artist class and for dealing with songs in the album class 
##so after this load data will delegate dealing with is to the appropriate class 
##start by reqriting load data class to delegate most of the work to the artist class 
##now we will call the method that have not beem wrtitten 
##it may seem odd but in OOOP you don't have to worry about how it is done but that it needed to be done and something else is responsible for getting it done .
##so i am for a bike repair i will not do it myself but look for the mechanic who encapsulate the skill or in case of building i wil look for the builder who encapsulte the 
knowledge ##so a bulder ENCAPSULTES THE skill reuired to build somthing that doesnot fall 



class Album :
    """class to represent an album using a track list
    attributes:
    album _name(str):the name of the album
    year(int): the year the album wa sreleased 
    artist :(Artist responsible for the album )
    if not specified the artist will default to an artist
    tracks (list):a list of song of the album 
    methods :
    add song:add a new  song to the album track list 
    """
    def __init__(self,name,year,artist=None ):
        self.name=name
        self.year=year
        if artist  is None :
             self.artist=Artist("Various artist ")
        else:
            self.artist=artist 
        self.tracks=[]    
    def add_song(self,song,position=None):
        """Adds a song to the track list 
        args:
        song[song]:song to add
        position (int):if specified song will be added to that postion in the track list 
        -inserting it between other songs if necessary """
        if position is None :
           self.tracks.append(song)
        else:
           self.tracks.insert(position,song)
        
class Artist :
    """basic class to store artist details 
    attributes :
    name(str): the name of the artist 
    album/List(album):a list of the album by the artist 
    the list includes only those album in the colletionit is not 
    an exhaust list of artist published albums 
    methods :add_albums :use to add a new album to the artist album list """
    def __init__(self,name ):
        self.name=name
        self.albums=[]
        
    def add_album(self,album):
        """add new album to the list..
        args: 
        album(Album ):album object to add to the list 
        if the album is already present .it will not added again(althpugh it is yet implemented"""
        self.albums.append(album)
    def add_song(self,name,year,title):
        """add a new song to the collection of the album 
            this method will add the song fot he colleciton to the 
            a new album is creatted if it doenot already exist 
            args:
            name(str):the name of the album
            year(int):the year the album was prodcued 
            title(str):title of the song """
        album_found=find_object(name,self.albums)
        if album_found is None:
            print(name+"Not found")
            album_found=Album(name,year,self)
            self.add_album(album_found)
        else :
            print(" ffound album"+name)
        album_found.add_song(title)    
def find_object(field,object_list):
    """check the object list to see if the object with a name attribute equal to the field exist, return it if so """
    for item in object_list:
        if item.name==field:
            return item 
    return None     
        
def load_data():
    #new_artist=None
    #new_album=None
    artist_list=[]##while doing encapsulation these thong are not needed.
    with open(r"C:\Users\home\Downloads\albums.txt","r") as albums:
       for line in albums:
            #data row shouldconsist of (artist,album,year,song)
         artist_field,album_field,year_field,song_field=tuple(line.strip('\n').split('\t'))
         year_field=int(year_field)
         print("{}:{}:{}:{}".format( artist_field,album_field,year_field,song_field))
         new_artist=find_object(artist_list,artist_field)
         if new_artist is None:
            new_artist=Artist(artist_field)
            artist_list.append(new_artist)
         new_artist.add_song(album_field,year_field,song_field)##THIS IS WHERE ENCAPSULATION OCCUR I.E GIVING OPERATION TO  SOMEONE AND NOT DOING BY OURSELVES
    return artist_list    


if __name__=='__main__':
    
    artists=load_data()
    print("there are{} artists".format(len(artists)))
   
   
   
   ###Getters and setters
   
   
   class Employee:
    def __init__(self,first,last):
        self.first=first
        self.last=last
        self.email=first+'.'+last+'@email.com'
    @property ##getter    
    def fullname(self):
        return'{} {}'.format(self.first,self.last)
emp_1=Employee('John','Smith')
emp_1.first='tim'
print(emp_1.first)
print(emp_1.email)
print(emp_1.fullname)
tim
John.Smith@email.com
tim Smith
##here email does not gets changed even after name is changed 
class Employee:
    def __init__(self,first,last):
        self.first=first
        self.last=last
       
    @property    ##using this setter property decorator even though we are defining as the function but we aree using it as the attribute 
    def email(self):
        return'{}.{}@email.com'.format(self.first,self.last)  
    @property
    def fullname(self):
        return'{} {}'.format(self.first,self.last)
     @fullname.setter##setter
    def fullname(self,name):##now this name value is the value we are trying to set 
        first,last=name.split(' ')
        self.first=first
        self.last=last
emp_1=Employee('John','Smith')
emp_1.fullname='corey schafer'
print(emp_1.first)
print(emp_1.email)
print(emp_1.fullname)
corey
corey.schafer@email.com
corey schafer


##abstract base classs


from abc import ABCMeta ,abstractmethod
class Shape(metaclass=ABCMeta):
    @abstractmethod##it means everyone has to define it 
    def printarea(self):##i.e every one have to print this method
        return 0
class Rectangle(Shape):
    type="Rectangle"
    sides=4
    def __init__(self):
        
     self.length=6    
     self.breadth=7
   # def printarea(self):
    #    return self.length*self.breadth##now if i want to have a class which calculates area for every function 
rect1=Rectangle()    
TypeError                                 Traceback (most recent call last)
<ipython-input-38-d98b8e98ac82> in <module>
     13    # def printarea(self):
     14     #    return self.length*self.breadth##now if i want to have a class which calculates area for every function
---> 15 rect1=Rectangle()

TypeError: Can't instantiate abstract class Rectangle with abstract methods printarea
    
    ##as we are inheriting form the shape class so we have to define this function 
    ##if we inherit any class from ABC Meta class that class say t child class to implement few method
    ##tryobj=Shape()##we can't make object to shape
    
class Employee:
    def __init__(self,fname,lname):
        self.fname=fname
        self.lname=lname
        #self.email=f"{fname}.{lname}@code woth harry.com"
    def explain(self):
        return f"This employee is {self.fname} {self.lname}"
    def email(self):
        return f"{self.fname}.{self.lname}@code with harry .com"
hindustani_supporter=Employee("Hindustani","Supporter")
nikhil_raj_pandey=Employee("Nikhil","Raj")
print(hindustani_supporter.explain())
print(hindustani_supporter.email())
hindustani_supporter.fname="US"
print(hindustani_supporter.email())
##answer is same reason is during the time of object creation and the constructor gets run then and hen it gets intialize 
#this problem is solved by the setter
This employee is Hindustani Supporter
Hindustani.Supporter@code with harry .com
US.Supporter@code with harry .com

##decorator 
class Employee:
    def __init__(self,fname,lname):
        self.fname=fname
        self.lname=lname
        #self.email=f"{fname}.{lname}@code woth harry.com"
    def explain(self):
        return f"This employee is {self.fname} {self.lname}"
    @property
    def email(self):
        return f"{self.fname}.{self.lname}@code with harry .com"
hindustani_supporter=Employee("Hindustani","Supporter")
nikhil_raj_pandey=Employee("Nikhil","Raj")
print(hindustani_supporter.explain())
print(hindustani_supporter.email)
hindustani_supporter.fname="US"
print(hindustani_supporter.email)
##answer is same reason is during the time of object creation and the constructor gets run then and hen it gets intialize 
#this problem is solved by the setter


class Employee:
    def __init__(self,fname,lname):
        self.fname=fname
        self.lname=lname
        #self.email=f"{fname}.{lname}@code woth harry.com"
    def explain(self):
        return f"This employee is {self.fname} {self.lname}"
    @property
    def email(self):
        return f"{self.fname}.{self.lname}@code with harry .com"
    @email.setter
    def email(self,string):
        names=string.split("@")[0]#it return the list
        self.fname=names.split(".")[0]
        self.lname=names.split(".")[1]
        
        
hindustani_supporter=Employee("Hindustani","Supporter")
nikhil_raj_pandey=Employee("Nikhil","Raj")
print(hindustani_supporter.explain())
print(hindustani_supporter.email)
hindustani_supporter.fname="US"
print(hindustani_supporter.email)
hindustani_supporter.email="this.that@codewithharry.com"
##answer is same reason is during the time of object creation and the constructor gets run then and hen it gets intialize 
#this problem is solved by the setter
##now i want to give email as input and as i give email as input it change the first and the last name .
##it is done by using setters
##first take the attribute which you want to take as input 
##then .setter 
print(hindustani_supporter.fname)
print(hindustani_supporter.lname)
print(hindustani_supporter.email)
This employee is Hindustani Supporter
Hindustani.Supporter@code with harry .com
US.Supporter@code with harry .com
this
that
this.that@code with harry .com

##here decorators can be used decorators allow us to define the method but we can access it like an attribute

##deleter
class Employee:
    def __init__(self,fname,lname):
        self.fname=fname
        self.lname=lname
        #self.email=f"{fname}.{lname}@code woth harry.com"
    def explain(self):
        return f"This employee is {self.fname} {self.lname}"
    @property
    def email(self):
        return f"{self.fname}.{self.lname}@code with harry .com"
    @email.setter
    def email(self,string):
        names=string.split("@")[0]#it return the list
        self.fname=names.split(".")[0]
        self.lname=names.split(".")[1]
    @email.deleter
    def email(self):
      self.fname=None
      self.lname=None   
        
hindustani_supporter=Employee("Hindustani","Supporter")
nikhil_raj_pandey=Employee("Nikhil","Raj")
print(hindustani_supporter.explain())
print(hindustani_supporter.email)
hindustani_supporter.fname="US"
print(hindustani_supporter.email)
hindustani_supporter.email="this.that@codewithharry.com"
##answer is same reason is during the time of object creation and the constructor gets run then and hen it gets intialize 
#this problem is solved by the setter
##now i want to give email as input and as i give email as input it change the first and the last name .
##it is done by using setters
##first take the attribute which you want to take as input 
##then .setter 
print(hindustani_supporter.fname)
print(hindustani_supporter.lname)
print(hindustani_supporter.email)
del hindustani_supporter.email
print(hindustani_supporter.email)
This employee is Hindustani Supporter
Hindustani.Supporter@code with harry .com
US.Supporter@code with harry .com
this
that
this.that@code with harry .com
None.None@code with harry .com

##generally we donot need them


##inheritance 

##base or super class and all our subclass will inherit the property of the super class and each subclass have their own property 
#class can have more than one property in additon to the one they inherit 

class Enemy:##this is the super class 

    def __init__(self, name="Enemy", hit_points=0, lives=1):##constructor
        self.name = name
        self.hit_points = hit_points
        self.lives = lives

    def take_damage(self, damage):
        remaining_points = self.hit_points - damage
        if remaining_points >= 0:
            self.hit_points = remaining_points
            print("I took {} points damage and have {} left".format(damage, self.hit_points))
        else:
            self.lives -= 1

    def __str__(self):
        return "Name: {0.name}, Lives: {0.lives}, Hit points: {0.hit_points}".format(self)

class Player(object):

    def __init__(self, name):
        self.name = name
        self._lives = 3
        self._level = 1
        self._score = 0

    def _get_lives(self):
        return self._lives

    def _set_lives(self, lives):
        if lives >= 0:
            self._lives = lives
        else:
            print("Lives cannot be negative")
            self._lives = 0

    def _get_level(self):
        return self._level

    def _set_level(self, level):
        if level > 0:
            delta = level - self._level
            self._score += delta * 1000
            self._level = level
        else:
            print("Level can't be less than 1")

    lives = property(_get_lives, _set_lives)
    level = property(_get_level, _set_level)

    @property
    def score(self):
        return self._score

    @score.setter
    def score(self, score):
        self._score = score

    def __str__(self):
        return "Name: {0.name}, Lives: {0.lives}, Level: {0.level}, Score {0.score}".format(self)

random_monster=Enemy("basic enemy",12,1)
print(random_monster)
random_monster.take_damage(4)
print(random_monster)
random_monster.take_damage(9)
print(random_monster)
random_monster.take_damage(1)
print(random_monster)

##CLASS METHOD##through this even my instance can access the class variable 
class Employee:
    no_of_leaves=8
    def __init__(self,aname,asalary,arole):
        self.name=aname
        self.salary=asalary
        self.role=arole
    def printdetails(self):
        return f"Name is {self.name}.Salary is {self.salary} and the role is {self.role}"
    @classmethod
    def change_leaves(cls,leaves):
        cls.no_of_leaves=leaves##here to change class directly
        #cls is that class whose nstance is harry 
        
harry=Employee("Harry",255,"Instructor")  
rohan=Employee("Rohan",455,"Student") 
print(harry.salary)
print(rohan.salary)
harry.change_leaves(34)
print(harry.no_of_leaves)
Employee.no_of_leaves=236
255
455
34



##the method which start with the double score is called the dunderinit it is a specil method it is a special method cuz it is a constructor 
and whenver the object is created it gets run .
class Employee:
    no_of_leaves=8
    def __init__(self,aname,asalary,arole):
        self.name=aname
        self.salary=asalary
        self.role=arole
    def printdetails(self):
        return f"Name is {self.name}.Salary is {self.salary} and the role is {self.role}"
    @classmethod
    def change_leaves(cls,newleaves):
        cls.no_of_leaves=newleaves##here to change class directly
        #cls is that class whose nstance is harry 
    def __add__(self,other):##it is called dunder add
     return self.salary+other.salary
emp1=Employee("Harry",345,"Programmer")
emp2=Employee("Rohan",85,"Cleaner")
print(emp1+emp2)
430


##when more than one method of the same name defined in the same class then it is called method overloading
##it is not possible in python 
##in python, if a method is written such that it can perform more than one task it is called method overloading 

class Myclass:
    def sum(self,a):
        print("1st method",a)
    def sum(self):
        print("2nd method")
obj=Myclass()
obj.sum()
obj.sum(10)
2nd method
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-79-b116f6566b49> in <module>
      6 obj=Myclass()
      7 obj.sum()
----> 8 obj.sum(10)
      9 
     10 

TypeError: sum() takes 1 positional argument but 2 were given
##in python this occur in case of method overloading
##so the method that is written at the last has the graeater prority 

##so basically to do in only one method two or three task 

class Myclass:
    def sum(self,a=None,b=None,c=None):
        if a!=None and b!=None and c!=None:
            s=a+b+c
        elif a!=None and b!=None:
            s=a+b
        else:
            s='Provide at least two numbers'
        return s       
obj=Myclass()
obj.sum(10,20)




##Trol has init in it here we have the error as we will first do the troll init slass an then enemy class






class Enemy:##this is the super class 

    def __init__(self, name="Enemy", hit_points=0, lives=1):##constructor
        self.name = name
        self.hit_points = hit_points
        self.lives = lives

    def take_damage(self, damage):
        remaining_points = self.hit_points - damage
        if remaining_points >= 0:
            self.hit_points = remaining_points
            print("I took {} points damage and have {} left".format(damage, self.hit_points))
        else:
            self.lives -= 1

    def __str__(self):
        return "Name: {0.name}, Lives: {0.lives}, Hit points: {0.hit_points}".format(self)
class Troll(Enemy):
    def __init__(self,name):
        pass
    



class Player(object):

    def __init__(self, name):
        self.name = name
        self._lives = 3
        self._level = 1
        self._score = 0

    def _get_lives(self):
        return self._lives

    def _set_lives(self, lives):
        if lives >= 0:
            self._lives = lives
        else:
            print("Lives cannot be negative")
            self._lives = 0

    def _get_level(self):
        return self._level

    def _set_level(self, level):
        if level > 0:
            delta = level - self._level
            self._score += delta * 1000
            self._level = level
        else:
            print("Level can't be less than 1")

    lives = property(_get_lives, _set_lives)
    level = property(_get_level, _set_level)

    @property
    def score(self):
        return self._score

    @score.setter
    def score(self, score):
        self._score = score

    def __str__(self):
        return "Name: {0.name}, Lives: {0.lives}, Level: {0.level}, Score {0.score}".format(self)

random_monster=Enemy("basic enemy",12,1)
print(random_monster)
random_monster.take_damage(4)
print(random_monster)
random_monster.take_damage(9)
print(random_monster)
random_monster.take_damage(1)
print(random_monster)
##several classes from the same module
ugly_troll = Troll("Pug")
print("Ugly troll - {}".format(ugly_troll))

another_troll = Troll("Ug", 18, 1)##use init of the enemy
#print("Another troll - {}".format(another_troll))

brother = Troll("Urg", 23)
print(brother)    
print("Another troll - {}".format(another_troll))
AttributeError                            Traceback (most recent call last)
<ipython-input-81-a191499feba9> in <module>
     76 ##several classes from the same module
     77 ugly_troll = Troll("Pug")
---> 78 print("Ugly troll - {}".format(ugly_troll))
     79 
     80 another_troll = Troll("Ug", 18, 1)##use init of the enemy

<ipython-input-81-a191499feba9> in __str__(self)
     15 
     16     def __str__(self):
---> 17         return "Name: {0.name}, Lives: {0.lives}, Hit points: {0.hit_points}".format(self)
     18 class Troll(Enemy):
     19     def __init__(self,name):

AttributeError: 'Troll' object has no attribute 'name'



##so we can write our enemy inside our troll to avoid the errror




##Overidding 
class A:
    classvar1="I am a classs variable in class A"
    def __init__(self):
        self.var1="I am inside Class A's constructor"
   #     self.classvar1="Instance var in class A"##isntance variable
class B(A):
    #classvar1="I am a classs variable in class B"##calss variable ##2.even if it is classvar1 still it will print self.classvar1 
    pass      3.after comenting self.classvar1 and classvar1 then it we have to go to classA classvar1 
a=A()
b=B()
print(b.classvar1)##1.now from here we will go to class B it will see is there any instacne variable then will see is there any class variabLE
#of the class from which it has inherited.##this is overriddding 



##using the super method
class A:
    classvar1="I am a classs variable in class A"
    def __init__(self):
        self.var1="I am inside Class A's constructor"
        self.classvar1="Instance var in class A"##isntance variable
        self.special="itis special "
class B(A):
    #classvar1="I am a classs variable in class B"
    def __init__(self):
        super().__init__()##now even if the calss A is overridden still we can call it 
        ##what super does is if we want the acess the attribute or the method then we can use the super 
        
        self.var1="I am inside Class B's constructor"##here if we run both the statement one by one by commenting out
        #we will see that Class has been overidden but if still i want to run the class A    
        self.classvar1="Instance var in class B"##isntance variable\
        print(super().classvar1)
        
        
a=A()
b=B()
print(b.special)
I am a classs variable in class A
itis special      


###duck typing

class Duck(object):

    def walk(self):
        print("Waddle, waddle, waddle")

    def swim(self):
        print("Come on it, the water's lovely")

    def quack(self):
        print("Quack quack")


class Penguin(object):

    def walk(self):
        print("Waddle, waddle, I waddle too")

    def swim(self):
        print("Come on in, but it's a bit chilly this far South")

    def quack(self):
        print("Are you 'avin' a larf? I'm a penguin!")


def test_duck(duck):
    duck.walk()
    duck.swim()
    duck.quack()

if __name__ == '__main__':
    donald = Duck()
    test_duck(donald)

    percy = Penguin()
    test_duck(percy)
    ##python is really interested in what can be done with AN OBJECT i.e it must have an 3 methods walk ,swim,quack it is called 
    #duck typing .it is i=not interested in the class but that it has the 3 function
    
 
##polymorphism 
 a=3
b="tim"
c=1,2,3
print(a)
print(b)
print(c)
##whats happpeing here is each object will behave in a similar way whn we try to print it
## a is int  and we substract two ints to work out their difference .b is a string and you can't subtrafct two string thus 
##a and b are two different type of object but both are printable so in that respect they behave like different type of object .
##the object that is printable 
##that ability of object to have different forms is called Polymorphism
##in this example the polymorphic behaviour of the objects is imlemented using inheritence .all python objects inherit from a base calss
##called object which defines a __str__ method


###SO POLYMORPHISM ALLOW THE PRINT FUNCTION TO ACCEPT ARGUMENT OF ANY TYPE AND ITS ABLE TO PRINT THEM OUT 
#int.__str__()
#float.__str__()
#list.__str__()
#tuple.__str__()
##they all behave as the printable object


##COMPOSITION
class Salary:
    def __init__(self,pay,bonus):
        self.pay=pay
        self.bonus=bonus
    def annual_salary(self):
        return (self.pay*12)+self.bonus
class Employee:
    def __init__(self,name,age,pay,bonus):
        self.name=name
        self.age=age
        self.obj_salary=Salary(pay,bonus)##we are instantitating slary clss inside the employeee class
    def total_salary(self):
        return self.obj_salary.annual_salary()
    ## we can see salary is not the employee and employeee is not the salary so inheritence cant be done
    ##here we have to use the composition it means we are delegating the resposibility from one class to the other calss 
    ##HERE EMPLOYEE CLASS IS DELEGATING SOME PART OF ITS RESPONSIBILITY TO THE OTHER CLASS
emp=Employee('max',25,15000,10000)


###ANOTHER EXAMPLE IS OF THE BOOK IS NOT THE CAHPTER AND THE CHAPTER IS NOT THE BOOK 


print(emp.total_salary())
