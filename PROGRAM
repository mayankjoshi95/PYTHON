#RAISE AN ERROR EXCEPTION



def banner_text(text):
    screen_width = 50
    if len(text) > screen_width - 4:
        raise ValueError("String{0}is larger then specified width{1}".format(text,screen_width))

    if text == "*":
        print("*" * screen_width)
    else:
        centred_text = text.center(screen_width - 4)
        output_string = "**{0}**".format(centred_text)
        print(output_string)


banner_text("*")
banner_text("Always look on the bright side of life...")
banner_text("If life seems jolly rotten,")
banner_text("There's something you've forgotten!")
banner_text("And that's to laugh and smile and dance and sing,")
banner_text(" ")
banner_text("When you're feeling in the dumps,")
banner_text("Don't be silly chumps,")
banner_text("Just purse your lips and whistle - that's the thing!")
banner_text("And... always look on the bright side of life...")
banner_text("*")





#palindrome




def palindrome(string:str)->bool:
    return string[::-1].casefold()==string.casefold()
word= input()
stri=palindrome(word)
print(stri)




#fibonacci Numbers



def  fibonacci(n):
    if 0<=n<=1:
        return n
    fe= 1
    
    fw= 0
    for f in range(n-1):
        result=int(fe)+int(fw)
        fw=fe
        fe=result
    return result

for i in range(32):
    print(i,fibonacci(i))





#args
def test_start(*args):
    print(args)
    for x in args:
        print(x)
test_start(0,1,2,3,4,5) 
 
 
 
 
 
 
 #DICTIONARY
 
 
 fruit={"orange":"sweet orange citrus fruit",
        "apple":"good for making cider",
         "lemon":"sour yellow citrus fruti",
      "grape":"samll fruit",
      "lime":"small citurs sour "}
print(fruit)
print(fruit['lemon'])
#assign new values to dictionary
fruit["banana"]="healthy"
print(fruit)
#overwriting
fruit["apple"]="verygood "
#delete 
del fruit["banana"]
#clear
fruit.clear()



#get method
while True:
    dict_key=input("Please enter a fruit")
    if dict_key=="quit":
        break
    description=fruit.get(dict_key)
    print(description)
    
    
    
    
    #sorting using keys and values
    #insted of keys place values()
   
  ordered_keys=fruits.keys()
ordered_keys=sorted(list(fruits.keys()))
print(ordered_keys)
for f in ordered_keys:
    print(f+"="+fruits[f])
    
    
    
    
    #tuple and dictionary
    
    f_tuple=tuple(fruits.items())
    for i in f_tuple:
    item,description=i
    print(item+"is"+description)

    
#join


mylist=["a","b","c","d"]
print(mylist)
newString=""

newString+=",".join(mylist)
print(newString)  







#update copy DICTIONARY


fruits={"orange":"sweet orange citrus fruit",
        "apple":"good for making cider",
         "lemon":"sour yellow citrus fruti",
         "grape":"samll fruit",
         "lime":"small citurs sour ",
         "apple":"healthy"}
veg={"cabage":"every childs favorite",
    "sprouts":"mm lovely",
    "spinach":"can i have some more fruits"}

nicenasty=fruits.copy()
nicenasty.update(veg)
print(nicenasty)




#sets,union,intersection






farmanimal={"sheep","cow","deer"}
print(farmanimal)
for animal in farmanimal:
    print(animal)
wild=set(["lion","tiger","panther"])
print(wild)
for animal in wild:
    print(animal)
empty_set=set()
empty_set.add("Sdds")
print(empty_set)

even=set(range(0,40,2))
print(even)
print(len(even))
square_tuple=(4,16,3,2,4)
squares=set(square_tuple)
print(squares)
print(len(squares))
print(even.union(squares))
print(len(even.union(squares)))
print(even.intersection(squares))
print(even-squares)
print(even.difference(squares))




#file 


jabber=open("/Users/home/.jupyter/sample.txt",'r')
for line in jabber:
     print(line,end='')
jabber.close()    




#using pickle





inelda="more mayhem","ineehlda may","2011",((1,"puling the rug"),(2,"psycho"),(3,"mayhem"),(4,"kentish town waltz"))
even=list(range(0,10,2))
odd=list(range(1,10,2))
with open("inelda.pickle","wb") as pickle_file:
    pickle.dump(inelda,pickle_file)
    pickle.dump(even,pickle_file)
    pickle.dump(odd,pickle_file)
    pickle.dump(29998302,pickle_file)
with open("inelda.pickle","rb")as inelda_pickled:
    inelda2=pickle.load(inelda_pickled)
    even_list=pickle.load(inelda_pickled)
    odd_list=pickle.load(inelda_pickled)
    x=pickle.load(inelda_pickled)
    
print(inelda2)
album,artist,year,track_list=inelda2
print(album)
print(artist)
print(year)
print(track_list)
for track in track_list:
    track_number,track_title=track
    print(track_number,track_title)
for i in even_list:
    print(i)
for i in odd_list:
    print(i)
print(x)    




#using shelves



import shelve
blt=["bacon","tomatoes","lettuce","bread"]
beans_on_toast=["beans","bread"]
scrambled_eggs=["eggs","butter","milk"]
soup=["tin of soup"]
pasta=["pasta","cheeze"]
with shelve.open("recipes",writeback=True) as recipes:
   # recipes["blt"]=blt
    #recipes["beans_on_toast"]=beans_on_toast
    #recipes["scrambled_eggs"]=scrambled_eggs
    #recipes["soup"]=soup
    #recipes["pasta"]=pasta
    recipes["soup"]=soup
    temp_list=recipes["blt"]
    temp_list.append("butter")
    recipes["blt"]=temp_list
    temp_list=recipes["pasta"]
    temp_list.append("tomato")
    recipes["pasta"]=temp_list
    recipes["soup"].append("cruotons")        
    
    for snack in recipes:
        print(snack,recipes[snack])
    
    
    
    
    
    
    #program using turtle
    
    
    
import turtle
turtle.forward(150)
turtle.right(250)
turtle.forward(150)





#why import * is a problem



done="well done you have finished the drawing"
from turtle import *
forward(150)
right(250)
forward(150)
done()
print(done)

<function mainloop at 0x000001F851FC4160>#output



#directory


print(dir())

#for example

for n in dir(__builtin__):
    print(n)
    
    
    import shelve
for obj in dir(shelve.Shelf):
    if obj[0]!="_":
        print(obj)

#open web browser in python
import webbrowser
webbrowser.open("https://www.unicef.org/")




#time

import time
print(time.gmtime(0))
print(time.localtime())
print(time.time())


time_here=time.localtime()
print(time_here)
print("year:",time_here[0],time_here.tm_year)
print("month",time_here[1],time_here.tm_mon)
print("day",time_here[2],time_here.tm_mday)


#program for storing my reaction time

import time
from time import perf_counter as my_timer #instead of perf_counter ;time can be used ,or process time can be used 
import random
input("please enter to start")
wait_time=random.randint(1,6)
time.sleep(wait_time)
start_time=my_timer()
input("press enter to stop")
end_time=my_timer()
print("started at"+time.strftime("%X",time.localtime(start_time)))
print("ended at"+time.strftime("%X",time.localtime(end_time)))
print("your reaction time was{}".format(end_time-start_time))



#date time  pytz



import pytz
import datetime
country="Europe/Moscow"
tz_to_display=pytz.timezone(country)
local_time=datetime.datetime.now(tz=tz_to_display)
print("the time in{}is {}\n\t".format(country,local_time))
print("UTCis {}\n\t".format(datetime.datetime.utcnow()))



for x in sorted(pytz.country_names):
    print("{}:{}:{}".format(x,pytz.country_names[x],pytz.country_timezones.get(x)))

#country with their time and how much ahead of utc

for x in sorted(pytz.country_names):
    print("{}:{}".format(x,pytz.country_names[x],end=':'))
    if x in pytz.country_timezones:
        for zone in sorted(pytz.country_timezones[x]):
            tz_to_display=pytz.timezone(zone)
            local_time=datetime.datetime.now(tz=tz_to_display)
            print(zone,local_time)
    else:
          print("no time zones")
          
          
         
#FUNCTION IN PYTHON
def text(*args):
    text=""
    for arg in args:
        text+=str(arg)
    left_margin=(80-len(text))//2
    print(" "*left_margin,text)
text("my name is mayank")   
text("my name is mfgdggsgseayank")
text(12)
text("my name is mayanksgdsgsfawfeagesgsgs")
text("sds",2,322,33,"sds")






#use of file in print function

def text(*args, sep='',end='\n', file=None, flush=False):
    text=""
    for arg in args:
        text+=str(arg)+sep
    left_margin=(80-len(text))//2
    print(" "*left_margin,text,end=end,file=file,flush=flush)
with open("centered",mode='w') as centered_file:
    
 text("my name is mayank",file=centered_file)   
 text("my name is mfgdggsgseayank",file=centered_file)
 text(12,file=centered_file)
 text("my name is mayanksgdsgsfawfeagesgsgs",file=centered_file)
 text("sds",2,322,33,"sds",sep="",file=centered_file)



#CLASS 
object oriented programming aims to combine data and the processes that act on that data into object called encapsulation

##encapsulation of data is the self lightng cigerrate 
withut object oriented programming steps for smoking the sigarrete is 
1.place cigarette in mouth 
2.lisght the match 
3.hold the match to cigrete
4. inhale 

encapsulation 
1.place cigarrete in mouth 
2. inhale 

but there is no magic involved here steps still has to be programmed so they are built into the object so anything using the object doesn't have to be concerned about them .
a=12
b=4
print(a+b)
print(a.__add__(b))
##here even if we send any thing it calls the same fucntion in .py file 
##in python everything is an object even types are implemeted as classes .
#when a function is  apart of class in pyhton it is called the method 


class Kettle(object):
power_source="electricity"
    def __init__(self , make,price):
        self.make=make
        self.price=price
        self.on=False##thus class can be thought of as a template from which object is created
    def switch_on(self):
      self.on=True
        #object created have the same name and the price 
        ##object created from the same class will share the same characteristics .
        ##so if i now create a kettle called kenwood then kettle will be an instance of the kettle class or kenwood is an obbject of type kettle a
kenwood=Kettle("kenwood",8.99)
print(kenwood.make)
print(kenwood.price)
kenwood.price=12.75
print(kenwood.price)
hamilton=Kettle("hamilton",14.55)
print("models:{0.make}={0.price},{1.make}={1.price}".format(kenwood,hamilton))
##each instance i.e the hamilton or the kenwood has its value for name and price  
##once the calss is defined then ewe can create as many instance of the class as we want .
#once the instance is created we can then call the method and access their variable 
#so kenwood.price retrieves the price from the instance called the kenwood .
##when a variable is bund to an instance of a class it is called data attribute
print(Kettle.power_source)
print(kenwood.power_source)
print(hamilton.power_source)
electricity
electricity
electricity
kenwood.power_source="atomic"
electricity
atomic
electricity


###Class:-template for creating the objects .all objects are created using the same classs will have the same chracteristics
###object :-an instance of the class
###instantiate :-create an instance of the class 
###method: a function defined in a class
###attribute :-a variable bound to an instance of the class
##difference between this method and the function is the self parameter 
##self :- it is the reference to the instance of the class and it is used to refer to instance variable 



##instances ,constructors ,self and more 
#CLASS bank balance
##print(hamilton.on)
##print(hamilton.switch_on())
##print(hamilton.on)
##Kettle.switch_on(kenwood)##calling the switch method in an alternative way so instead of using the instance of the kettle to call we used class itsel f
##print(kenwood.on)
##constructor :-special method executed when the instance of the class is created or constructed ##in python it is the init method on the line 3

###along with thhe instance variable there can also be the class attribute 

class Account:
    """simple account class with balance"""
    def __init__(self,name,balance):
        self.name=name
        self.balance=balance
        print("account created for"+name)
    def deposit(self,amount):    
        if amount>0:
            self.balance+=amount
            self.show_balance()
    def withdraw(self,amount):
        if 0<amount<=self.balance:
            self.balance-=amount
        else:
            print("greater than alowed")
            self.show_balance()
    def show_balance(self):
        print("balance is {}".format(self.balance))
if __name__=="__main__":
    tim=Account("tim",0)
  #  tim.show_balance()
    tim.deposit(1000)
    tim.withdraw(50000)
   # tim.show_balance()
    
##if name=='__main__'##name value is equal to the main if your are running int he same program the fucntion you are calling 
def printhar(string):
    return f"ye string de de {string}"
def add(num1,num2):
    return num1 +num2+5
if __name__=='__main__':##if we import tut1 then only the function performed in the second is executed unless not 
#here it says that if name === main then only execute so when name ==main only when it is its function
    print(printhar("harry 1"))
    o=add(4,5)
    print(o)
ye string de de harry 1
14

import tut1
print(tut1.add(4,3))
12








#sepositing and withdrawing amount and showing their utc time

import datetime
import pytz
class Account:
    """simple account class with balance"""
    @staticmethod
    def _current_time():
        utc_time=datetime.datetime.utcnow()
        return pytz.utc.localize(utc_time)
    def __init__(self,name,balance):
        self.name=name
        self.balance=balance
        self.transaction_list=[]
        print("account created for"+name)
    def deposit(self,amount):    
        if amount>0:
            self.balance+=amount
            self.show_balance()
            self.transaction_list.append((Account._current_time(),amount))
    def withdraw(self,amount):
        if 0<amount<=self.balance:
            self.balance-=amount
            self.transaction_list.append((Account._current_time(),-amount))
        else:
            print("greater than alowed")
            self.show_balance()
    def show_balance(self):
        print("balance is {}".format(self.balance))
    def show_transations(self):
        for date,amount in self.transaction_list:
            if amount>0:
                tran_type="deposited"
            else:
                tran_type="withdraw"
                amount*=-1
            print("local time was",amount,tran_type,date,date.astimezone())    
if __name__=="__main__":
    tim=Account("tim",0)
  #  tim.show_balance()
    tim.deposit(1000)
    tim.withdraw(7)
    tim.show_balance()
    tim.show_transations()
    steph=Account("steph",800)
    steph.deposit(100)
    steph.withdraw(200)
    steph.show_transations()
    steph=Account("steph",800)
    steph.deposit(800)
    steph.withdraw(400)
    steph.show_transations()
###raw string  :help to not use \\ it help in case where we have to put \ at the end of the line .
##DOCSTRINGS 
class Song :
    """Class to represent a song 
    Attributes :
    title(str):title of the song 
    artist(artist) :an artist object represneting the song creater
    duration (int):duration of the song in second 
    """
    def __init__(self,title,artist,duration=0):
     """Song init method 
     Args:
     title(str):initialises the 'title 'attribute 
     artist(Artist):an artist object representig the song creator 
     duration(optional (int)):;initial value for the duration of the attributes 
     will default value to the zero if not specified """
     self.title =title 
     self.artist=artist
     self.duration=duration     
help(Song.__init__.__doc__)    
Song.__init__.__doc__= """Song init method 
     Args:
     title(str):initialises the 'title 'attribute 
     artist(Artist):an artist object representig the song creator 
     duration(optional (int)):;initial value for the duration of the attributes 
     will default value to the zero if not specified """
help(Song)


class Album :
    """class to represent an album using a track list
    attributes:
    album _name(str):the name of the album
    year(int): the year the album wa sreleased 
    artist :(Artist responsible for the album )
    if not specified the artist will default to an artist
    tracks (list):a list of song of the album 
    methods :
    add song:add a new  song to the album track list 
    """
    def __init__(self,name,year,artist=None ):
        self.name=name
        self.year=year
        if artist  is None :
             self.artist=Artist("Various artist ")
        else:
            self.artist=artist 
        self.tracks=[]    
    def add_song(self,song,postion=None):
        """Adds a song to the track list 
        args:
        song[song]:song to add
        position (int):if specified song will be added to that postion in the track list 
        -inserting it between other songs if necessary """
        if position is None :
           self.tracks.append(song)
        else:
           self.tracks.insert(position,song)
        
class Artist :
    """basic class to store artist details 
    attributes :
    name(str): the name of the artist 
    album/List(album):a list of the album by the artist 
    the list includes only those album in the colletionit is not 
    an exhaust list of artist published albums 
    methods :add_albums :use to add a new album to the artist album list """
    def __init__(self,name ):
        self.name=name
        self.albums=[]
        
    def add_album(self,album):
        """add new album to the list..
        args: 
        album(Album ):album object to add to the list 
        if the album is already present .it will not added again(althpugh it is yet implemented"""
        self.albums.append(album)
def load_data():
    new_artist=None
    new_album=None
    artist_list=[]
    with open("C:\\Users\\home\\Downloads\\albums.txt","r") as albums:
       for line in albums:
            #data row shouldconsist of (artist,album,year,song)
         artist_field,album_field,year_field,song_field=tuple(line.strip('\n').split('\t'))
         year_field=int(year_field)
         print( artist_field,album_field,year_field,song_field) 
         if new_artist is None :
                new_artist=Artist(artist_field)
         elif new_artist.name!=artist_field:
            #we've just read the details for the new artist 
            #store the current album in the current artist collection then create a new artist object 
            new_artist.add_album(new_album)
            artist_list.append(new_artist)
            new_artist=Artist(artist_field)
            new_album=None 
         if new_album is None :
                new_album=Album(album_field,year_field,new_artist)
         elif new_album.name!=album_field:
            #we've just read the details for the new album
            #store the current album in the current artist collection then create a new artist object 
            new_artist.add_album(new_album)
            new_album=Album(album_field,year_field,new_artist)
         #create a new song object anndadd it to the current album's collection   
         new_song=Song(song_field,new_artist)
         new_album.add_song(new_song)
         if new_artist is not None :
                 if new_album is not None :
                        new_artist.add_album(new_album)
                 artist_list.append(new_artist)
    return artist_list             
if __name__=='__main__':
    
    load_data()


num1=(input())
num2=(input())
try:
 print(" the number is ",int(num1)+int(num2))
except Exception as e:
    print(e)
print("this is something")
wee
6
invalid literal for int() with base 10: 'wee'
this is something


##check file 
def create_checkfile(artist_list):
    """create a check file from the object data for the coparision with the original file"""
    with open("checkfile.txt","w") as checkfile:
        for new_artist in artist_list:
            for new_album in new_artist.albums:
                for new_song in new_album.tracks:
                    print("{0.name}\t{1.name}\t{1.year}\t{2.title}".format(new_artist,new_album,new_song),file=checkfile)
    

##encasulting involvess encapsulating data and methods
###it deals with question such as which object is best suited to deal with this task or where does responsibility to perform this function belong 
##here load data does all the work of passing the data and working out when it finds the new album and a new song  .here the one who know most about the album is the artist and 
albums knows all about songs 
##so we really should encapsulte the method for dealing wth albums in the artist class and for dealing with songs in the album class 
##so after this load data will delegate dealing with is to the appropriate class 
##start by reqriting load data class to delegate most of the work to the artist class 
##now we will call the method that have not beem wrtitten 
##it may seem odd but in OOOP you don't have to worry about how it is done but that it needed to be done and something else is responsible for getting it done .
##so i am for a bike repair i will not do it myself but look for the mechanic who encapsulate the skill or in case of building i wil look for the builder who encapsulte the 
knowledge ##so a bulder ENCAPSULTES THE skill reuired to build somthing that doesnot fall 



class Album :
    """class to represent an album using a track list
    attributes:
    album _name(str):the name of the album
    year(int): the year the album wa sreleased 
    artist :(Artist responsible for the album )
    if not specified the artist will default to an artist
    tracks (list):a list of song of the album 
    methods :
    add song:add a new  song to the album track list 
    """
    def __init__(self,name,year,artist=None ):
        self.name=name
        self.year=year
        if artist  is None :
             self.artist=Artist("Various artist ")
        else:
            self.artist=artist 
        self.tracks=[]    
    def add_song(self,song,position=None):
        """Adds a song to the track list 
        args:
        song[song]:song to add
        position (int):if specified song will be added to that postion in the track list 
        -inserting it between other songs if necessary """
        if position is None :
           self.tracks.append(song)
        else:
           self.tracks.insert(position,song)
        
class Artist :
    """basic class to store artist details 
    attributes :
    name(str): the name of the artist 
    album/List(album):a list of the album by the artist 
    the list includes only those album in the colletionit is not 
    an exhaust list of artist published albums 
    methods :add_albums :use to add a new album to the artist album list """
    def __init__(self,name ):
        self.name=name
        self.albums=[]
        
    def add_album(self,album):
        """add new album to the list..
        args: 
        album(Album ):album object to add to the list 
        if the album is already present .it will not added again(althpugh it is yet implemented"""
        self.albums.append(album)
    def add_song(self,name,year,title):
        """add a new song to the collection of the album 
            this method will add the song fot he colleciton to the 
            a new album is creatted if it doenot already exist 
            args:
            name(str):the name of the album
            year(int):the year the album was prodcued 
            title(str):title of the song """
        album_found=find_object(name,self.albums)
        if album_found is None:
            print(name+"Not found")
            album_found=Album(name,year,self)
            self.add_album(album_found)
        else :
            print(" ffound album"+name)
        album_found.add_song(title)    
def find_object(field,object_list):
    """check the object list to see if the object with a name attribute equal to the field exist, return it if so """
    for item in object_list:
        if item.name==field:
            return item 
    return None     
        
def load_data():
    #new_artist=None
    #new_album=None
    artist_list=[]##while doing encapsulation these thong are not needed.
    with open(r"C:\Users\home\Downloads\albums.txt","r") as albums:
       for line in albums:
            #data row shouldconsist of (artist,album,year,song)
         artist_field,album_field,year_field,song_field=tuple(line.strip('\n').split('\t'))
         year_field=int(year_field)
         print("{}:{}:{}:{}".format( artist_field,album_field,year_field,song_field))
         new_artist=find_object(artist_list,artist_field)
         if new_artist is None:
            new_artist=Artist(artist_field)
            artist_list.append(new_artist)
         new_artist.add_song(album_field,year_field,song_field)##THIS IS WHERE ENCAPSULATION OCCUR I.E GIVING OPERATION TO  SOMEONE AND NOT DOING BY OURSELVES
    return artist_list    


if __name__=='__main__':
    
    artists=load_data()
    print("there are{} artists".format(len(artists)))
   
   
   
   ###Getters and setters
   
   
   class Employee:
    def __init__(self,first,last):
        self.first=first
        self.last=last
        self.email=first+'.'+last+'@email.com'
    @property ##getter    
    def fullname(self):
        return'{} {}'.format(self.first,self.last)
emp_1=Employee('John','Smith')
emp_1.first='tim'
print(emp_1.first)
print(emp_1.email)
print(emp_1.fullname)
tim
John.Smith@email.com
tim Smith
##here email does not gets changed even after name is changed 
class Employee:
    def __init__(self,first,last):
        self.first=first
        self.last=last
       
    @property    ##using this setter property decorator even though we are defining as the function but we aree using it as the attribute 
    def email(self):
        return'{}.{}@email.com'.format(self.first,self.last)  
    @property
    def fullname(self):
        return'{} {}'.format(self.first,self.last)
     @fullname.setter##setter
    def fullname(self,name):##now this name value is the value we are trying to set 
        first,last=name.split(' ')
        self.first=first
        self.last=last
emp_1=Employee('John','Smith')
emp_1.fullname='corey schafer'
print(emp_1.first)
print(emp_1.email)
print(emp_1.fullname)
corey
corey.schafer@email.com
corey schafer

##here decorators can be used decorators allow us to define the method but we can access it like an attribute
